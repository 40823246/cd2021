var tipuesearch = {"pages": [{'title': 'About', 'text': '倉儲: https://github.com/40823246/cd2021 \n 小組成員網站: 40823208李翊帆 \n 小組網站: https://40823208.github.io/stage1-bg8/content/About.html \n 小組gitter: https://gitter.im/40823208/stage1-bg8 \n', 'tags': '', 'url': 'About.html'}, {'title': '每周進度', 'text': '', 'tags': '', 'url': '每周進度.html'}, {'title': 'stage1-bg8', 'text': 'w1 \n \n 影片: \n 2021 協同產品設計實習 stage1 bg8 \n \n \n w2 \n 影片: \n w2 2021 協同產品設計實習 stage1 bg8 \n 檔案下載: https://drive.google.com/file/d/1A2OD-HsjxqEZE4VA-dOrMSLWLWxn2uR6/view?usp=sharing \n \n \n Day1 \n 20210306 \n 自動零食為食機的盒子完成 \n \n Day2 \n 20210307 \n 上升螺旋桿完成 \n \n Day3 \n 20210308 \n 修改盒子:1.新增螺桿洞 2.加入斜坡讓食物集中 \n \n Day4 \n 20210309 \n 1.修改斜度 2.加入擋板 \n \n 增加螺桿長度，讓模擬時穩定一點 \n \n Day5 \n 20210310 \n 模擬時，球體會上不去，所以在底部增加斜角，方便將球體鏟起 \n \n Day6 \n 20210311 \n 因為此機構垂直運行沒辦法將球體往上帶，加上我們想到更好的點子，所以我們決定換題目，但是沿用舊機構，以下是新主題(自動分球機)。 \n 主體 \n \n 螺旋桿 \n \n w3 \n 零件總結影片 \n \n \n 圖案下載: https://drive.google.com/file/d/1A2OD-HsjxqEZE4VA-dOrMSLWLWxn2uR6/view?usp=sharing \n 20210313 \n 模擬時發現孔比軸大，有間隙，旋轉時軸會跳飛，所以把孔改成與軸一樣直徑，30mm > 20mm \n \n 模擬時發現螺旋葉片會卡到縫裡，所以把一長條的縫改成洞 \n \n 繪製鋼珠盒 \n \n 20210314 \n 模擬時孔面與螺旋桿摩擦，導致螺旋桿莫名亂跳，因此加大孔徑 \n \n 繪製大鋼珠盒，讓大量鋼珠慢慢涓流 \n 1 \n', 'tags': '', 'url': 'stage1-bg8.html'}, {'title': 'stage2-bg1', 'text': "w5 \n 20210326 \n 討論做什麼 \n 結論: \n 轉子引擎 \n \n \n w6 \n 利用追蹤頂點路徑 取得不規則曲線草圖(20rpm) \n \n \n 20210402 \n 繪製轉子 \n 外型參考 勒洛三角形 繪製而成 \n 齒數為52齒 模數為2 \n \n 20210403 \n 偏心軸繪製完成 \n \n 20210404 \n 擋板繪製完成 \n 齒數為34齒 模數為2 \n \n 20210405 \n 外殼繪製完成 \n 輪廓為不規則曲面  擷取不規則取線方法 \n \n 20210406 \n 組合圖完成 \n \n solidworks模擬影片(20rpm) \n \n > \n 20210407 \n 因為在coppeliasim中模擬屢次失敗，所以我們決定換題目。 \n \n w7 \n 討論改什麼 \n \n 結論:堆高機 \n \n 20210411 \n 前輪繪製完成 \n \n 後輪繪製完成 \n \n 底盤繪製完成 \n \n 20210413 \n \n 20210414 \n 擋板繪製完成 \n \n 堆高機組合圖完成 \n \n 20210415 \n 加入wasd控制堆高機 \n 參考: https://mdekmol.github.io/cd2019a-task1-2019cda_t1_g2/content/Vrep-2.html \n \n function sysCall_init() \n    left_front_handle= sim.getObjectHandle('left_joint')\n    left_back_handle= sim.getObjectHandle('left_joint')\n    right_back_handle= sim.getObjectHandle('right_joint')\n    right_front_handle= sim.getObjectHandle('right_joint')\n    MaxVel=2\n    leftvelocity=0\n    rightvelocity=0\n    dVel=100;\n    --sim.setJointTargetVelocity(left_front_handle,leftvelocity)\n    sim.setJointTargetVelocity(left_back_handle,leftvelocity)\n    sim.setJointTargetVelocity(right_back_handle,rightvelocity)\n    --sim.setJointTargetVelocity(right_front_handle,rightvelocity)\nend\n\nfunction sysCall_actuation() \n    message,auxiliaryData=sim.getSimulatorMessage()\n    while message~=-1 do\n        if (message==sim.message_keypress) then\n            if (auxiliaryData[1]==32) then\n                -- right key\n                leftvelocity=0\n                rightvelocity=0\n                sim.setJointForce(left_front_handle, 0)\n                sim.setJointForce(left_back_handle, 0)\n                sim.setJointForce(right_back_handle, 0)\n                sim.setJointForce(right_front_handle, 0)\n                break\n            else\n                --sim.setJointForce(left_front_handle, 10000)\n                sim.setJointForce(left_back_handle, 10000)\n                sim.setJointForce(right_back_handle, 10000)\n                --sim.setJointForce(right_front_handle, 10000)\n            end\n            if (auxiliaryData[1]==119) then\n                -- w key\n                leftvelocity=(leftvelocity+rightvelocity)/2\n                rightvelocity=leftvelocity\n                leftvelocity=leftvelocity+dVel\n                rightvelocity=rightvelocity+dVel\n            end\n            if (auxiliaryData[1]==115) then\n                -- s key\n                leftvelocity=(leftvelocity+rightvelocity)/2\n                rightvelocity=leftvelocity\n                leftvelocity=leftvelocity-dVel\n                rightvelocity=rightvelocity-dVel\n            end\n            if (auxiliaryData[1]==97) then\n                -- a key\n                leftvelocity=leftvelocity-dVel\n                rightvelocity=rightvelocity+dVel\n            end\n            if (auxiliaryData[1]==100) then\n                -- d key\n                leftvelocity=leftvelocity+dVel\n                rightvelocity=rightvelocity-dVel\n            end\n        end\n        message,auxiliaryData=sim.getSimulatorMessage()\n    end\n    \n    if leftvelocity>MaxVel then\n        leftvelocity=MaxVel\n    end\n    if leftvelocity<-MaxVel then\n        leftvelocity=-MaxVel\n    end\n    \n    if rightvelocity>MaxVel then\n                rightvelocity=MaxVel\n    end\n    if rightvelocity<-MaxVel then\n                rightvelocity=-MaxVel\n    end\n    \n    --sim.setJointTargetVelocity(left_front_handle,leftvelocity)\n    sim.setJointTargetVelocity(left_back_handle,leftvelocity)\n    sim.setJointTargetVelocity(right_back_handle,rightvelocity)\n    --sim.setJointTargetVelocity(right_front_handle,rightvelocity)\n    \nend  \n 程式 \n \n w8 \n 20210417 \n 齒輪繪製完成，齒數為51，模數為2 \n \n 在插鏟上增加齒條，模數為2 \n \n 20210418 \n 加入方向鍵控制插鏟功能 \n \n 程式: \n function sysCall_init() \n    left_front_handle= sim.getObjectHandle('left_joint')\n    left_back_handle= sim.getObjectHandle('left_joint')\n    right_back_handle= sim.getObjectHandle('right_joint')\n    right_front_handle= sim.getObjectHandle('right_joint')\n    gear_up_handle= sim.getObjectHandle('gear_joint')\n    gear_down_handle= sim.getObjectHandle('gear_joint')\n    MaxVel=10\n    MaxVel_gear=30\n    leftvelocity=0\n    rightvelocity=0\n    upvelocity=0\n    dVel=10;\n    dVel_gear=10;\n    --sim.setJointTargetVelocity(left_front_handle,leftvelocity)\n    sim.setJointTargetVelocity(left_back_handle,leftvelocity)\n    sim.setJointTargetVelocity(right_back_handle,rightvelocity)\n    sim.setJointTargetVelocity(gear_down_handle,upvelocity)\n    --sim.setJointTargetVelocity(right_front_handle,rightvelocity)\nend\n\nfunction sysCall_actuation() \n    message,auxiliaryData=sim.getSimulatorMessage()\n    while message~=-1 do\n        if (message==sim.message_keypress) then\n            if (auxiliaryData[1]==32) then\n                leftvelocity=0\n                rightvelocity=0\n                upvelocity=0\n                sim.setJointForce(left_front_handle, 0)\n                sim.setJointForce(left_back_handle, 0)\n                sim.setJointForce(right_back_handle, 0)\n                sim.setJointForce(right_front_handle, 0)\n                sim.setJointForce(gear_up_handle, 0)\n                sim.setJointForce(gear_down_handle, 0)\n                break\n            else\n                --sim.setJointForce(left_front_handle, 10000)\n                sim.setJointForce(left_back_handle, 10000)\n                sim.setJointForce(right_back_handle, 10000)\n                sim.setJointForce(gear_down_handle, 10000)\n                --sim.setJointForce(right_front_handle, 10000)\n            end\n            if (auxiliaryData[1]==119) then\n                -- w key\n                leftvelocity=(leftvelocity+rightvelocity)/2\n                rightvelocity=leftvelocity\n                leftvelocity=leftvelocity+dVel\n                rightvelocity=rightvelocity+dVel\n            end\n            if (auxiliaryData[1]==115) then\n                -- s key\n                leftvelocity=(leftvelocity+rightvelocity)/2\n                rightvelocity=leftvelocity\n                leftvelocity=leftvelocity-dVel\n                rightvelocity=rightvelocity-dVel\n            end\n            if (auxiliaryData[1]==97) then\n                -- a key\n                leftvelocity=leftvelocity-dVel\n                rightvelocity=rightvelocity+dVel\n            end\n            if (auxiliaryData[1]==100) then\n                -- d key\n                leftvelocity=leftvelocity+dVel\n                rightvelocity=rightvelocity-dVel\n            end\n            if (auxiliaryData[1]==100) then\n                -- d key\n                leftvelocity=leftvelocity+dVel\n                rightvelocity=rightvelocity-dVel\n            end\n            if (auxiliaryData[1]==2008) then\n                -- up key\n                upvelocity=upvelocity+dVel_gear\n            end\n            if (auxiliaryData[1]==2007) then\n                -- down key\n                upvelocity=upvelocity-dVel_gear\n            end\n            \n        end\n        message,auxiliaryData=sim.getSimulatorMessage()\n    end\n    \n    if leftvelocity>MaxVel then\n        leftvelocity=MaxVel\n    end\n    if leftvelocity<-MaxVel then\n        leftvelocity=-MaxVel\n    end\n    \n    if rightvelocity>MaxVel then\n                rightvelocity=MaxVel\n    end\n    if rightvelocity<-MaxVel then\n                rightvelocity=-MaxVel\n    end\n    if upvelocity>MaxVel_gear then\n                    upvelocity=MaxVel_gear\n    end\n    if upvelocity<-MaxVel_gear then\n                    upvelocity=-MaxVel_gear\n    end\n    \n    --sim.setJointTargetVelocity(left_front_handle,leftvelocity)\n    sim.setJointTargetVelocity(left_back_handle,leftvelocity)\n    sim.setJointTargetVelocity(right_back_handle,rightvelocity)\n    sim.setJointTargetVelocity(gear_down_handle,upvelocity)\n    --sim.setJointTargetVelocity(right_front_handle,rightvelocity)\n    \nend  \n 20210422 \n 修改齒輪長度，增加強度 \n \n 原本中間一根尺條改成兩旁兩根尺，增加抓力，改善駕駛員視線 \n \n 成品圖: \n \n 修改後成果 \n \n 程式 \n function sysCall_init() \n    left_front_handle= sim.getObjectHandle('left_joint')\n    left_back_handle= sim.getObjectHandle('left_joint')\n    right_back_handle= sim.getObjectHandle('right_joint')\n    right_front_handle= sim.getObjectHandle('right_joint')\n    gear_up_handle= sim.getObjectHandle('gear_joint')\n    gear_down_handle= sim.getObjectHandle('gear_joint')\n    MaxVel=20\n    MaxVel_gear=30\n    leftvelocity=0\n    rightvelocity=0\n    upvelocity=0\n    dVel=10;\n    dVel_gear_up=30;\n    dVel_gear_dwon=20;\n    a=13;\n    --sim.setJointTargetVelocity(left_front_handle,leftvelocity)\n    sim.setJointTargetVelocity(left_back_handle,leftvelocity)\n    sim.setJointTargetVelocity(right_back_handle,rightvelocity)\n    sim.setJointTargetVelocity(gear_down_handle,upvelocity)\n    --sim.setJointTargetVelocity(right_front_handle,rightvelocity)\nend\n\nfunction sysCall_actuation() \n    message,auxiliaryData=sim.getSimulatorMessage()\n    while message~=-1 do\n        if (message==sim.message_keypress) then\n            if (auxiliaryData[1]==32) then\n                leftvelocity=0\n                rightvelocity=0\n                upvelocity=0\n                sim.setJointForce(left_front_handle, 0)\n                sim.setJointForce(left_back_handle, 0)\n                sim.setJointForce(right_back_handle, 0)\n                sim.setJointForce(right_front_handle, 0)\n                sim.setJointForce(gear_up_handle, 0)\n                sim.setJointForce(gear_down_handle, 0)\n                break\n            else\n                --sim.setJointForce(left_front_handle, 10000)\n                sim.setJointForce(left_back_handle, 10000)\n                sim.setJointForce(right_back_handle, 10000)\n                sim.setJointForce(gear_down_handle, 10000)\n                --sim.setJointForce(right_front_handle, 10000)\n            end\n            if (auxiliaryData[1]==119) then\n                -- w key\n    \n                leftvelocity=leftvelocity+a\n                rightvelocity=rightvelocity+dVel\n            end\n            if (auxiliaryData[1]==115) then\n                -- s key\n                leftvelocity=(leftvelocity+rightvelocity)/2\n                rightvelocity=leftvelocity\n                leftvelocity=leftvelocity-dVel\n                rightvelocity=rightvelocity-dVel\n            end\n            if (auxiliaryData[1]==97) then\n                -- a key\n                leftvelocity=leftvelocity-dVel\n                rightvelocity=rightvelocity+dVel\n            end\n            if (auxiliaryData[1]==100) then\n                -- d key\n                leftvelocity=leftvelocity+dVel\n                rightvelocity=rightvelocity-dVel\n            end\n            if (auxiliaryData[1]==100) then\n                -- d key\n                leftvelocity=leftvelocity+dVel\n                rightvelocity=rightvelocity-dVel\n            end\n            if (auxiliaryData[1]==2008) then\n                -- down key\n                upvelocity=upvelocity+dVel_gear_dwon\n            end\n            if (auxiliaryData[1]==2007) then\n                -- up key\n                upvelocity=upvelocity-dVel_gear_up\n            end\n            \n        end\n        message,auxiliaryData=sim.getSimulatorMessage()\n    end\n    \n    if leftvelocity>MaxVel then\n        leftvelocity=MaxVel\n    end\n    if leftvelocity<-MaxVel then\n        leftvelocity=-MaxVel\n    end\n    \n    if rightvelocity>MaxVel then\n                rightvelocity=MaxVel\n    end\n    if rightvelocity<-MaxVel then\n                rightvelocity=-MaxVel\n    end\n    if upvelocity>MaxVel_gear then\n                    upvelocity=MaxVel_gear\n    end\n    if upvelocity<-MaxVel_gear then\n                    upvelocity=-MaxVel_gear\n    end\n    \n    --sim.setJointTargetVelocity(left_front_handle,leftvelocity)\n    sim.setJointTargetVelocity(left_back_handle,leftvelocity)\n    sim.setJointTargetVelocity(right_back_handle,rightvelocity)\n    sim.setJointTargetVelocity(gear_down_handle,upvelocity)\n    --sim.setJointTargetVelocity(right_front_handle,rightvelocity)\n    \nend  \n", 'tags': '', 'url': 'stage2-bg1.html'}, {'title': '檔案下載', 'text': '轉子引擎(未完成): \n 轉子引擎包.zip \n \n 堆高機: \n 堆高機包.zip (圖檔與程式) \n \n', 'tags': '', 'url': '檔案下載.html'}, {'title': '參考資料', 'text': '轉子引擎: \n https://www.youtube.com/watch?v=nA5vAulVHbw \n https://www.youtube.com/watch?v=fec0z_BOSzo \n https://zh.wikipedia.org/wiki/ \n \n 堆高機: \n 繪圖參考 \n http://www.hsintai.tw/nissan \n http://www.yang-forklift.com.tw/_i/assets/upload/images/2018-10-19_092303.png \n 程式參考 \n https://mdekmol.github.io/cd2019a-task1-2019cda_t1_g2/content/Vrep-2.html \n', 'tags': '', 'url': '參考資料.html'}, {'title': 'stage3-bg1', 'text': 'w9 \n 討論做什麼 \n \n w10 \n 20210504 \n remote api(python) 連動成功 \n \n 20210505 \n 新增控制插鏟功能 \n \n 20210506 \n 新增控制推高機前後左右功能 \n \n \xa020210512 \n 巡路小車 \n \n 20210513 \n 凸輪stage2，爬不上去，待改善 \n \n \n 20210514 \n 來回走直線 \n \n \n 20210520 \n 堆高機搬運測試A to B \n \n 20210524 \n 將機械手臂改成改成一鍵往前 > 抓取 >往後 >放開，增加抓取成功機率。 \n downloads \n 主要程式碼: \n \n #angle = math.pi/180\nif keyboard.is_pressed("t"):\n            print("You pressed t")\n           \n            vrep.simxSetJointTargetPosition(clientID,vertical_handle,0.5,opmode)\n            time.sleep(0.5)\n            vrep.simxSetJointTargetPosition(clientID,cam_handle,angle*90,opmode)\n            time.sleep(0.5)\n            vrep.simxSetJointTargetPosition(clientID,vertical_handle,0.1,opmode)\n            time.sleep(5)\n            vrep.simxSetJointTargetPosition(clientID,cam_handle,angle*0,opmode) \n \n \n 20210604 \n 加入rgb偵測啟動夾爪。 \n \n downloads \n 主要程式碼: \n  #rgb辨識-----\n        returnCode,resolution,image=vrep.simxGetVisionSensorImage(clientID,vision_handle,0,opmode)#取得圖片\n        color = np.asarray(image)#將圖片數據轉成矩陣形式\n        color.shape = (resolution[1], resolution[0], 3)\n        color = color.astype(np.float)#-1~1\n        color[color < 0] += 255\n        color = np.fliplr(color)#因為得到得圖片數據是上下左右顛倒的，所以要將數據在顛倒一次才能轉正\n        color = color.astype(np.uint8)#0~255\n        rgb=color[1]\n        rgb2=rgb[1]\n        print(rgb2)\n        rgb3=[139,139,163]#掃地機器人的顏色\n        rgb4=[0,0,147]\n        #rgb辨識-----\n        \n        #夾爪程式(rgb作動)-----\n        if all(rgb2==rgb3):\n            vrep.simxSetJointTargetPosition(clientID,vertical_handle,0.5,opmode)\n            time.sleep(0.5)\n            vrep.simxSetJointTargetPosition(clientID,cam_handle,angle*90,opmode)\n            time.sleep(0.5)\n            vrep.simxSetJointTargetPosition(clientID,vertical_handle,0.1,opmode)\n            time.sleep(5)\n            vrep.simxSetJointTargetPosition(clientID,cam_handle,angle*0,opmode)\n        #夾爪程式(rgb作動)----- \n 20210618 \n 更新RGB辨識程式，因為每個產品顏色多少有一點點的差異，所以把條件設置在一定範圍內。 \n #rgb辨識-----\n        returnCode,resolution,image=vrep.simxGetVisionSensorImage(clientID,vision_handle,0,opmode)#取得圖片\n        color = np.asarray(image)#將圖片數據轉成矩陣形式\n        color.shape = (resolution[1], resolution[0], 3)\n        color = color.astype(np.float)#-1~1\n        color[color < 0] += 255\n        color = np.fliplr(color)#因為得到得圖片數據是上下左右顛倒的，所以要將數據在顛倒一次才能轉正\n        color = color.astype(np.uint8)#0~255\n        rgb=color[1]\n        rgb2=rgb[1]\n        r=rgb2[0]\n        g=rgb2[1]\n        b=rgb2[2]\n        print(rgb2)\n        rgb3=[139,139,163]#掃地機器人的顏色\n        rgb4=[0,0,147]\n        #rgb辨識-----\n        \n        #夾爪程式(rgb作動)-----\n        if 167>b>161 and 142>r>136 and 142>g>136:#設置一定範圍\n            vrep.simxSetJointTargetPosition(clientID,vertical_handle,0.5,opmode)\n            time.sleep(0.5)\n            vrep.simxSetJointTargetPosition(clientID,cam_handle,angle*90,opmode)\n            time.sleep(0.5)\n            vrep.simxSetJointTargetPosition(clientID,vertical_handle,0.1,opmode)\n            time.sleep(5)\n            vrep.simxSetJointTargetPosition(clientID,cam_handle,angle*0,opmode)\n        #夾爪程式(rgb作動)----- \n 檔案下載 \n \n \n \n', 'tags': '', 'url': 'stage3-bg1.html'}, {'title': 'task2', 'text': '將小組stage2 採用remote api\xa0 \n 使用python keyboard插件: https://pypi.org/project/keyboard/ \n 讓堆高機可以用鍵盤控制 \n \n 程式: \n # File created by Thibaut Royer, Epitech school\n# thibaut1.royer@epitech.eu\n# It intends to be an example program for the "Two wheels, one arm" educative project.\n\nimport sim as vrep\nimport math\nimport random\nimport time\nimport keyboard\n\n\nprint (\'Start\')\n\n# Close eventual old connections\nvrep.simxFinish(-1)\n# Connect to V-REP remote server\nclientID = vrep.simxStart(\'192.168.1.116\', 19997, True, True, 5000, 5)\n\nif clientID != -1:\n    print (\'Connected to remote API server\')\n    \n    res = vrep.simxAddStatusbarMessage(\n        clientID, "40823246",\n        vrep.simx_opmode_oneshot)\n    if res not in (vrep.simx_return_ok, vrep.simx_return_novalue_flag):\n        print("Could not add a message to the status bar.")\n\n    \n    opmode = vrep.simx_opmode_oneshot_wait\n    \n\n    \n    vrep.simxStartSimulation(clientID, opmode)\n    ret,front_handle=vrep.simxGetObjectHandle(clientID,"front_joint",opmode)\n    ret,left_handle=vrep.simxGetObjectHandle(clientID,"left_joint",opmode)\n    ret,right_handle=vrep.simxGetObjectHandle(clientID,"right_joint",opmode)\n    ret,gear_handle=vrep.simxGetObjectHandle(clientID,"gear_joint",opmode)\n    #ret,main = vrep.simxGetObjectHandle(clientID, "main", opmode)\n    while True:\n        #keyboard "w" \n        if keyboard.is_pressed("w"):\n            vrep.simxSetJointTargetVelocity(clientID,front_handle,1000,opmode)\n            vrep.simxSetJointTargetVelocity(clientID,left_handle,1000,opmode)\n            vrep.simxSetJointTargetVelocity(clientID,right_handle,1000,opmode)\n            \n        #keyboard "s" \n        if keyboard.is_pressed("s"):\n            vrep.simxSetJointTargetVelocity(clientID,front_handle,-1000,opmode)\n            vrep.simxSetJointTargetVelocity(clientID,left_handle,-1000,opmode)\n            vrep.simxSetJointTargetVelocity(clientID,right_handle,-1000,opmode)\n        \n        #keyboard "a" \n        if keyboard.is_pressed("a"):\n            vrep.simxSetJointTargetVelocity(clientID,front_handle,5,opmode)\n            vrep.simxSetJointTargetVelocity(clientID,left_handle,1000,opmode)\n            vrep.simxSetJointTargetVelocity(clientID,right_handle,0,opmode)\n        \n        #keyboard "d" \n        if keyboard.is_pressed("d"):\n            vrep.simxSetJointTargetVelocity(clientID,front_handle,5,opmode)\n            vrep.simxSetJointTargetVelocity(clientID,left_handle,0,opmode)\n            vrep.simxSetJointTargetVelocity(clientID,right_handle,1000,opmode)\n        \n        #keyboard "w+a" \n        if keyboard.is_pressed("w+a"):\n            vrep.simxSetJointTargetVelocity(clientID,front_handle,500,opmode)\n            vrep.simxSetJointTargetVelocity(clientID,left_handle,1000,opmode)\n            vrep.simxSetJointTargetVelocity(clientID,right_handle,0,opmode)\n        \n        #keyboard "w+d" \n        if keyboard.is_pressed("w+d"):\n            vrep.simxSetJointTargetVelocity(clientID,front_handle,500,opmode)\n            vrep.simxSetJointTargetVelocity(clientID,left_handle,0,opmode)\n            vrep.simxSetJointTargetVelocity(clientID,right_handle,1000,opmode)\n        \n        #keyboard "space" \n        if keyboard.is_pressed("space"):\n            vrep.simxSetJointTargetVelocity(clientID,front_handle,0,opmode)\n            vrep.simxSetJointTargetVelocity(clientID,left_handle,0,opmode)\n            vrep.simxSetJointTargetVelocity(clientID,right_handle,0,opmode)\n            \n        vrep.simxSetJointTargetVelocity(clientID,gear_handle,-0,opmode)\n        \n        #keyboard "8" \n        if keyboard.is_pressed("8"):\n            vrep.simxSetJointTargetVelocity(clientID,gear_handle,-30,opmode)\n        \n        #keyboard "5" \n        if keyboard.is_pressed("5"):\n            vrep.simxSetJointTargetVelocity(clientID,gear_handle,15,opmode)\n        \n        #keyboard "esc" \n        if  keyboard.is_pressed("esc"):\n            vrep.simxStopSimulation(clientID, opmode)\n            break\n        \nelse:\n    print (\'Failed connecting to remote API server\')\n    print (\'End\')\n \n \n', 'tags': '', 'url': 'task2.html'}, {'title': '筆記', 'text': '', 'tags': '', 'url': '筆記.html'}, {'title': 'coppeliasim 新增球體,旋轉軸應用', 'text': '1.如何新增一個直徑0.2,有物理屬性的球體? \n \n 然後將x-size(直徑)調至0.2,然後按[Ok]。 \n --- \n 2.如何再複製一個? \n 對Sphere案右鍵 \n \n 然後到Edit貼上 \n \n 然後兩顆一模一樣的球就會重疊在一起。 \n --- \n 3.如何移動球體? \n 點選紅圈內的按鈕,然後再輕點想移動的球體。 \n \n 這個視窗可以調整X,Y,Z軸的自由度(勾選即可解鎖自由度)。 \n \n --- \n 4.如何新增感測器? \n 新增完再將感測器拖曳到Sphere中。 \n \n 接著調整感測器位置,輕點感測器,再點紅色底線按鈕,X輸入0.1,Z輸入0.12。 \n \n 調整感測器大小參數,輕點感測器,點選紅色底線按鈕,offset輸入0.005,range輸入0.1,angle輸入30。 \n \n --- \n 5.如何新增車輪: \n 首先新增一個新場景。 \n 新增圓柱體，並調整大小 尺寸為（0.08,0.08,0.02）。 \n \n \n \n 在該圓柱的 object common properties 中啟用 \xa0 Collidable，Measurable，Renderable 和 Detectable。 \n 調整圓柱體位置 將圓柱的絕對位置設置為（0.05,0.1,0.04），並將其絕對方向設置為（-90,0,0)。 \n \n 改名為 bubbleRob_leftWheel 並複製。 \n 貼上，並調整絕對位置設置y為-0.1Y在改名為 bubbleRob_rightWheel。 \n 複製兩個輪子並貼到主場景。 \n --- \n 6.有了輪子,那如何新增馬達? \n \n 案ctrl,讓馬達與左輪都在選中狀態 \n 點選 \n \n \n 在position中,點擊apply to selection \n 點選 \n \n \n 在orientation中,點擊apply to selection \n 將輪子拖入馬達中 \n 選中馬達,點選 \n \n \n 點選 \n \n 勾選 \n \n', 'tags': '', 'url': 'coppeliasim 新增球體,旋轉軸應用.html'}, {'title': '組員fork git pull 注意事項', 'text': '當組長倉儲版本較新時(組長是最後一個推送的)，組員必須git pull，更新倉儲。 \n 組員git pull之前先進 \n .git資料夾 > 修改config中url的學號，改為組長的 > git pull >改回自己的。 \n', 'tags': '', 'url': '組員fork git pull 注意事項.html'}, {'title': 'reveal 功能', 'text': '添加圖片(圖檔要放在倉儲中reveal資料夾) \n <image src="圖片.png" width="600" hight="300"> \n 修改width hight數值可以改圖片大小。 \n \n 加入背景圖片 (圖檔要放在倉儲中reveal資料夾) \n <section data-background="圖片.png"> \n 在一開始的section加入即可。 \n \n 加入pdf預覽功能(pdf 檔要放在倉儲中reveal資料夾 ) \n  <iframe data-src="報告.pdf" width="800" height="600" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:3px solid #666; margin-bottom:5px; max-width: 100%;" allowfullscreen> </iframe> \n 修改width hight數值可以改視窗大小。 \n \n 嵌入影片 \n <iframe width="560" height="315" src="影片網址" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>\n</section> \n 修改width hight數值可以改視窗大小。 \n', 'tags': '', 'url': 'reveal 功能.html'}, {'title': 'remote api', 'text': 'clientID: 如果連接失敗,clientID=-1。 \n simxGetObjectHandle(clientID, "軸的名字" ,opmode): 軸的前置設定。 \n vrep.simxStartSimulation(clientID, opmode): 自動幫你按開始鍵。 \n vrep.simxStopSimulation(clientID, opmode):自動 重置vrep。 \n simxSetJointTargetVelocity(clientID,軸,弳度,opmode): 控制軸旋轉幾度。 \n', 'tags': '', 'url': 'remote api.html'}, {'title': 'W5', 'text': 'W5.xlsx \n \n', 'tags': '', 'url': 'W5.html'}, {'title': 'w15', 'text': '影片翻譯1(開啟cc字幕) \n \n 影片翻譯2(開啟cc字幕) \n \n', 'tags': '', 'url': 'w15.html'}, {'title': 'w16', 'text': '\n 1.Onshape 零組件繪製 https://cad.onshape.com/documents/95be919eff337bcfb3d48a31/w/7141046f74a1cb6c4eb8b963/e/9540969522d181481ee4a819 \n 繪製過程: \n \n \n 2.建立 CoppeliaSim 4.1.0 MTB robot 場景 影片: https://www.youtube.com/watch?v=fIN-mSlv8K4 檔案下載: https://drive.google.com/file/d/1udJ1NMeyMnoSBGd3NPWcxbkaqaUAw0Mi/view?usp=sharing \n joint type使用Passive mode，參見: 網址 \n 程式: \n function sysCall_init()\n    -- 設定個軸\n    joint_hanld1=sim.getObjectHandle(\'joint1\')\n    joint_hanld2=sim.getObjectHandle(\'joint2\')\n    joint_hanld3=sim.getObjectHandle(\'joint3\')\n    joint_hanld4=sim.getObjectHandle(\'joint4\')\n    suctionPad=sim.getObjectHandle(\'suctionPad\')\n    -- 賦值\n    angle=math.pi/180\n    angle1=0\n    angle2=0\n    d=0\n    a1=0.8 --手臂長度1\n    a2=0.8 --手臂長度2\nend\n\nfunction sysCall_actuation()\n    -- 鍵盤控制代碼\n    message, auxiliaryData=sim.getSimulatorMessage()\n        while message ~= -1 do\n            key=auxiliaryData[1]\n            sim.addStatusbarMessage(\'????? key:\'..key)\n            if (message==sim.message_keypress) then\n                if (auxiliaryData[1]==100) then --d\n                    -- if key a pressed joint1 left\n                    angle1=angle1+angle\n                    sim.setJointPosition(joint_hanld1,angle1)\n                end -- if d\n                if (auxiliaryData[1]==97) then --a \n                    -- if key d pressed joint1 right\n                    angle1=angle1-angle\n                    sim.setJointPosition(joint_hanld1,angle1)\n                end -- if a\n                if (auxiliaryData[1]==101) then --e\n                    -- if key e pressed joint2 left\n                    angle2=angle2+angle\n                    sim.setJointPosition(joint_hanld2,angle2)\n                end -- if d\n                if (auxiliaryData[1]==113) then --q \n                    -- if key q pressed joint2 right\n                    angle2=angle2-angle\n                    sim.setJointPosition(joint_hanld2,angle2)\n                end -- if a\n                if (auxiliaryData[1]==56) then --8\n                    -- if key 8 pressed suctionpad up and active=ture\n                    d=d-0.05\n                    sim.setJointPosition(joint_hanld3,d)\n                    sim.setScriptSimulationParameter(sim.getScriptAssociatedWithObject(suctionPad),\'active\',\'ture\')\n                end -- if 8\n                if (auxiliaryData[1]==53) then --5\n                    -- if key 8 pressed suctionpad down \n                    sim.setJointPosition(joint_hanld3,0.084)\n                end -- if 5\n                if (auxiliaryData[1]==115) then --s\n                    -- if key s pressed active=false\n                    sim.setScriptSimulationParameter(sim.getScriptAssociatedWithObject(suctionPad),\'active\',\'false\')\n                end -- if 5\n                message, auxiliaryData=sim.getSimulatorMessage()\n            end\n        end  \nend \n \n 3.手臂末端加入 components-gripper-suction pad 吸盤\xa0 影片: https://youtu.be/H0d0PgtyghM \n 吸盤程式: \n function sysCall_init() \n    s=sim.getObjectHandle(\'suctionPadSensor\')\n    l=sim.getObjectHandle(\'suctionPadLoopClosureDummy1\')\n    l2=sim.getObjectHandle(\'suctionPadLoopClosureDummy2\')\n    b=sim.getObjectHandle(\'suctionPad\')\n    suctionPadLink=sim.getObjectHandle(\'suctionPadLink\')\n\n    infiniteStrength=sim.getScriptSimulationParameter(sim.handle_self,\'infiniteStrength\')\n    maxPullForce=sim.getScriptSimulationParameter(sim.handle_self,\'maxPullForce\')\n    maxShearForce=sim.getScriptSimulationParameter(sim.handle_self,\'maxShearForce\')\n    maxPeelTorque=sim.getScriptSimulationParameter(sim.handle_self,\'maxPeelTorque\')\n\n    sim.setLinkDummy(l,-1)\n    sim.setObjectParent(l,b,true)\n    m=sim.getObjectMatrix(l2,-1)\n    sim.setObjectMatrix(l,-1,m)\nend\n\nfunction sysCall_cleanup() \n--[[\n    sim.setLinkDummy(l,-1)\n    sim.setObjectParent(l,b,true)\n    m=sim.getObjectMatrix(l2,-1)\n    sim.setObjectMatrix(l,-1,m)\n]]--\nend \n\nfunction sysCall_sensing() \n    parent=sim.getObjectParent(l)\n    if (sim.getScriptSimulationParameter(sim.handle_self,\'active\')==false) then\n        if (parent~=b) then\n            sim.setLinkDummy(l,-1)\n            sim.setObjectParent(l,b,true)\n            m=sim.getObjectMatrix(l2,-1)\n            sim.setObjectMatrix(l,-1,m)\n        end\n    else\n        if (parent==b) then\n            -- Here we want to detect a respondable shape, and then connect to it with a force sensor (via a loop closure dummy dummy link)\n            -- However most respondable shapes are set to "non-detectable", so "sim.readProximitySensor" or similar will not work.\n            -- But "sim.checkProximitySensor" or similar will work (they don\'t check the "detectable" flags), but we have to go through all shape objects!\n            index=0\n            while true do\n                shape=sim.getObjects(index,sim.object_shape_type)\n                if (shape==-1) then\n                    break\n                end\n                if (shape~=b) and (sim.getObjectInt32Parameter(shape,sim.shapeintparam_respondable)~=0) and (sim.checkProximitySensor(s,shape)==1) then\n                    -- Ok, we found a respondable shape that was detected\n                    -- We connect to that shape:\n                    -- Make sure the two dummies are initially coincident:\n                    sim.setObjectParent(l,b,true)\n                    m=sim.getObjectMatrix(l2,-1)\n                    sim.setObjectMatrix(l,-1,m)\n                    -- Do the connection:\n                    sim.setObjectParent(l,shape,true)\n                    sim.setLinkDummy(l,l2)\n                    break\n                end\n                index=index+1\n            end\n        else\n            -- Here we have an object attached\n            if (infiniteStrength==false) then\n                -- We might have to conditionally beak it apart!\n                result,force,torque=sim.readForceSensor(suctionPadLink) -- Here we read the median value out of 5 values (check the force sensor prop. dialog)\n                if (result>0) then\n                    breakIt=false\n                    if (force[3]>maxPullForce) then breakIt=true end\n                    sf=math.sqrt(force[1]*force[1]+force[2]*force[2])\n                    if (sf>maxShearForce) then breakIt=true end\n                    if (torque[1]>maxPeelTorque) then breakIt=true end\n                    if (torque[2]>maxPeelTorque) then breakIt=true end\n                    if (breakIt) then\n                        -- We break the link:\n                        sim.setLinkDummy(l,-1)\n                        sim.setObjectParent(l,b,true)\n                        m=sim.getObjectMatrix(l2,-1)\n                        sim.setObjectMatrix(l,-1,m)\n                    end\n                end\n            end\n        end\n    end\n    if (sim.getSimulationState()==sim.simulation_advancing_lastbeforestop) then\n        sim.setLinkDummy(l,-1)\n        sim.setObjectParent(l,b,true)\n        m=sim.getObjectMatrix(l2,-1)\n        sim.setObjectMatrix(l,-1,m)\n    end\nend  \n \n 4.逆向運動學函式 影片: https://youtu.be/7pV9-aCR06I \n 檔案下載: \n MTB_force mode.zip \n 在 \xa0 non-threaded child script \xa0 模式下不能使用sim.wait，所以使用threaded child script \n 如果要在 non-threaded child script \xa0 模式下用 延遲函數，可以參考: 網址 \n 程式: \n function sysCall_threadmain()\n    -- 設定個軸\n    joint_hanld1=sim.getObjectHandle(\'joint1\')\n    joint_hanld2=sim.getObjectHandle(\'joint2\')\n    joint_hanld3=sim.getObjectHandle(\'joint3\')\n    suctionPad=sim.getObjectHandle(\'suctionPad\') --吸盤\n    --賦值\n    angle=180/math.pi\n    angle1=math.pi/180\n    d=0\n    x=0.7 --(m)\n    y=0.2 --(m)\n    --逆向運動學函式\n    function round(x, n) \n    n = math.pow(10, n or 0)\n    x = x * n\n    if x >= 0 then x = math.floor(x + 0.5) else x = math.ceil(x - 0.5) end\n    return x / n\nend\n \n-- radian to degree\ndeg = 180/math.pi\n-- link 1 length\na1 = 0.8 --手臂長度1(m)\n-- link 2 length\na2 = 0.8 --手臂長度2(m)\n-- derivated based upon https://www.youtube.com/watch?v=IKOGwoJ2HLk&t=311s\nfunction ik(x, y)\n    -- (x, y) need to be located inside the circle with radius a1+a2\n    if (x^2 + y^2) <= (a1+ a2)^2 then\n        q2 = -math.acos((x^2+y^2-a1^2-a2^2)/(2*a1*a2))\n        q1 = math.atan2(y, x) + math.atan2((a2*math.sin(q2)), (a1+a2*math.cos(q2)))\n        return {round(q1*deg, 4), round(q2*deg, 4)}\n    else\n        print("Over range!")\n    end\nend\n \ntheta = ik(0.7, 0.2)\n \nprint(theta[1], theta[2])\n            sim.setJointTargetPosition(joint_hanld1,-theta[1]*angle1)\n            sim.setJointTargetPosition(joint_hanld2,theta[2]*angle1)\n            sim.wait(3)\n    --(0.2,0.7,0) 和 (-0.3,-0.55,0)來回取放\n    while(true)\n        do  \n            sim.wait(3)\n            sim.setJointTargetPosition(joint_hanld3,0.06)\n            sim.wait(3)\n            sim.setScriptSimulationParameter(sim.getScriptAssociatedWithObject(suctionPad),\'active\',\'ture\')\n            sim.wait(3)\n            sim.setJointTargetPosition(joint_hanld3,-0.06)\n            sim.wait(3)\n            theta = ik(-0.55, -0.3)\n            sim.wait(3)\n            sim.setJointTargetPosition(joint_hanld1,-theta[1]*angle1)\n            sim.setJointTargetPosition(joint_hanld2,theta[2]*angle1)\n            sim.wait(10)\n            sim.setJointTargetPosition(joint_hanld3,0.06)\n            sim.wait(3)\n            sim.setScriptSimulationParameter(sim.getScriptAssociatedWithObject(suctionPad),\'active\',\'false\')\n            sim.wait(3)\n            sim.setJointTargetPosition(joint_hanld3,-0.06)\n            sim.wait(3)\n            sim.setScriptSimulationParameter(sim.getScriptAssociatedWithObject(suctionPad),\'active\',\'ture\')\n            sim.wait(3)\n            sim.setJointTargetPosition(joint_hanld3,0.06)\n            sim.wait(3)\n            sim.setJointTargetPosition(joint_hanld3,-0.06)\n            sim.wait(3)\n            theta = ik(0.7, 0.2)\n            sim.setJointTargetPosition(joint_hanld1,-theta[1]*angle1)\n            sim.setJointTargetPosition(joint_hanld2,theta[2]*angle1)\n            sim.wait(10)\n            sim.setJointTargetPosition(joint_hanld3,0.06)\n            sim.wait(3)\n            sim.setScriptSimulationParameter(sim.getScriptAssociatedWithObject(suctionPad),\'active\',\'false\')\n            sim.wait(3)\n            sim.setJointTargetPosition(joint_hanld3,-0.06)\n    end   \n    \n    \n    \nend\n \n \n 5.Python remote API 逆向運動學函式 影片: https://youtu.be/ACHYQvS25A0 \n 檔案下載: \n MTB_remote api python.zip \n 程式: \n import sim as vrep\nimport math\nimport random\nimport time\nimport keyboard\n\n\nprint (\'Start\')\n\n# Close eventual old connections\nvrep.simxFinish(-1)\n# Connect to V-REP remote server\nclientID = vrep.simxStart(\'192.168.1.116\', 19997, True, True, 5000, 5)\n\nif clientID != -1:\n    print (\'Connected to remote API server\')\n    \n    res = vrep.simxAddStatusbarMessage(\n        clientID, "40823246",\n        vrep.simx_opmode_oneshot)\n    if res not in (vrep.simx_return_ok, vrep.simx_return_novalue_flag):\n        print("Could not add a message to the status bar.")\n\n    \n    opmode = vrep.simx_opmode_oneshot_wait\n    angle1=math.pi/180\n    \n    # radian to degree\n    deg = 180/math.pi\n    # link 1 length\n    a1 = 0.8\n    # link 2 length\n    a2 = 0.8\n    # derivated based up https://www.youtube.com/watch?v=IKOGwoJ2HLk&t=311s\n     \n    def ik(x, y):\n        # (x, y)  need to be located inside the circle with radius a1+a2\n        if (x**2 + y**2) <= (a1+ a2)**2:\n            q2 = -math.acos((x**2+y**2-a1**2-a2**2)/(2*a1*a2))\n            q1 = math.atan2(y, x) + math.atan2((a2*math.sin(q2)), (a1+a2*math.cos(q2)))\n            # The decimal point of number is rounded to the 4th place\n            return [round(q1*deg, 4), round(q2*deg, 4)]\n        else:\n            print("Over range!")\n            # end the script execution\n \n    theta = ik(0.7, 0.2)\n \n    print(theta[0], theta[1])\n    \n    vrep.simxStartSimulation(clientID, opmode)\n    ret,joint_hanld1=vrep.simxGetObjectHandle(clientID,"joint1",opmode)\n    ret,joint_hanld2=vrep.simxGetObjectHandle(clientID,"joint2",opmode)\n    ret,joint_hanld3=vrep.simxGetObjectHandle(clientID,"joint3",opmode)\n    ret,suctionPad=vrep.simxGetObjectHandle(clientID,"suctionPad",opmode)\n    vrep.simxSetJointTargetPosition(clientID,joint_hanld1,-theta[0]*angle1,opmode)\n    vrep.simxSetJointTargetPosition(clientID,joint_hanld2,theta[1]*angle1,opmode)\n    time.sleep(0.5)\n    while True:\n            time.sleep(0.5)\n            vrep.simxSetJointTargetPosition(clientID,joint_hanld3,0.06,opmode)\n            time.sleep(0.5)\n            vrep.simxSetIntegerSignal(clientID,"pad_switch",1,opmode)\n            time.sleep(0.5)\n            vrep.simxSetJointTargetPosition(clientID,joint_hanld3,-0.06,opmode)\n            time.sleep(0.5)\n            theta = ik(-0.55, -0.3)\n            time.sleep(0.5)\n            vrep.simxSetJointTargetPosition(clientID,joint_hanld1,-theta[0]*angle1,opmode)\n            vrep.simxSetJointTargetPosition(clientID,joint_hanld2,theta[1]*angle1,opmode)\n            time.sleep(2)\n            vrep.simxSetJointTargetPosition(clientID,joint_hanld3,0.06,opmode)\n            time.sleep(0.5)\n            vrep.simxSetIntegerSignal(clientID,"pad_switch",0,opmode)\n            time.sleep(0.5)\n            vrep.simxSetJointTargetPosition(clientID,joint_hanld3,-0.06,opmode)\n            time.sleep(0.5)\n            vrep.simxSetIntegerSignal(clientID,"pad_switch",1,opmode)\n            time.sleep(0.5)\n            vrep.simxSetJointTargetPosition(clientID,joint_hanld3,0.06,opmode)\n            time.sleep(0.5)\n            vrep.simxSetJointTargetPosition(clientID,joint_hanld3,-0.06,opmode)\n            time.sleep(0.5)\n            theta = ik(0.7, 0.2)\n            vrep.simxSetJointTargetPosition(clientID,joint_hanld1,-theta[0]*angle1,opmode)\n            vrep.simxSetJointTargetPosition(clientID,joint_hanld2,theta[1]*angle1,opmode)\n            time.sleep(2)\n            vrep.simxSetJointTargetPosition(clientID,joint_hanld3,0.06,opmode)\n            time.sleep(0.5)\n            vrep.simxSetIntegerSignal(clientID,"pad_switch",0,opmode)\n            time.sleep(0.5)\n            vrep.simxSetJointTargetPosition(clientID,joint_hanld3,-0.06,opmode)\n    end\n        \nelse:\n    print (\'Failed connecting to remote API server\')\n    print (\'End\') \n \n 因為在原本吸盤程式是藉由更改"active" 的值，ture or false，來決定吸盤是否生效，但我在 python remote api 中 找不到可以更改"active"的功能，所以使用 40823214 的吸盤程式，只要更改"pad_switch"的值，0 or 1，即可 決定吸盤是否生效。 \n 找到最類似的功能: simxSetBooleanParameter \n 吸盤程式(使用 40823214 的程式): \n function sysCall_init() \n    --this is teach by 40823214\n    objectHandle=sim.getObjectHandle(\'suctionPad\')\n    sim.setUserParameter(objectHandle,\'@enable\',\'\')\n    modelBase=sim.getObjectAssociatedWithScript(sim.handle_self)\n    robotBase=modelBase\n    while true do\n        robotBase=sim.getObjectParent(robotBase)\n        if robotBase==-1 then\n            robotName=\'Dobot\'\n            break\n        end\n        robotName=sim.getObjectName(robotBase)\n        suffix,suffixlessName=sim.getNameSuffix(robotName)\n        if suffixlessName==\'Dobot\' then\n            break\n        end\n    end\n\n    s=sim.getObjectHandle(\'suctionPadSensor\')\n    l=sim.getObjectHandle(\'suctionPadLoopClosureDummy1\')\n    l2=sim.getObjectHandle(\'suctionPadLoopClosureDummy2\')\n    b=sim.getObjectHandle(\'suctionPad\')\n    suctionPadLink=sim.getObjectHandle(\'suctionPadLink\')\n    local gripperBase=sim.getObjectAssociatedWithScript(sim.handle_self)\n\n    infiniteStrength=sim.getScriptSimulationParameter(sim.handle_self,\'infiniteStrength\')\n    maxPullForce=sim.getScriptSimulationParameter(sim.handle_self,\'maxPullForce\')\n    maxShearForce=sim.getScriptSimulationParameter(sim.handle_self,\'maxShearForce\')\n    maxPeelTorque=sim.getScriptSimulationParameter(sim.handle_self,\'maxPeelTorque\')\n\n    sim.setLinkDummy(l,-1)\n    sim.setObjectParent(l,b,true)\n    m=sim.getObjectMatrix(l2,-1)\n    sim.setObjectMatrix(l,-1,m)\nend\n\nfunction sysCall_cleanup() \n    --this is teach by 40823214\n    sim.setLinkDummy(l,-1)\n    sim.setObjectParent(l,b,true)\n    m=sim.getObjectMatrix(l2,-1)\n    sim.setObjectMatrix(l,-1,m)\nend \n\nfunction sysCall_sensing() \n    parent=sim.getObjectParent(l)\n    --this is teach by 40823214\n    local sig=sim.getIntegerSignal("pad_switch")\n    if (not sig) or (sig==0) then\n        if (parent~=b) then\n            sim.setLinkDummy(l,-1)\n            sim.setObjectParent(l,b,true)\n            m=sim.getObjectMatrix(l2,-1)\n            sim.setObjectMatrix(l,-1,m)\n        end\n    else\n        if (parent==b) then\n            index=0\n            while true do\n                shape=sim.getObjects(index,sim.object_shape_type)\n                if (shape==-1) then\n                    break\n                end\n                local res,val=sim.getObjectInt32Parameter(shape,sim.shapeintparam_respondable)\n                if (shape~=b) and (val~=0) and (sim.checkProximitySensor(s,shape)==1) then\n                    -- Ok, we found a respondable shape that was detected\n                    -- We connect to that shape:\n                    -- Make sure the two dummies are initially coincident:\n                    sim.setObjectParent(l,b,true)\n                    m=sim.getObjectMatrix(l2,-1)\n                    sim.setObjectMatrix(l,-1,m)\n                    -- Do the connection:\n                    sim.setObjectParent(l,shape,true)\n                    sim.setLinkDummy(l,l2)\n                    break\n                end\n                index=index+1\n            end\n        else\n            -- Here we have an object attached\n            if (infiniteStrength==false) then\n                -- We might have to conditionally beak it apart!\n                result,force,torque=sim.readForceSensor(suctionPadLink) -- Here we read the median value out of 5 values (check the force sensor prop. dialog)\n                if (result>0) then\n                    breakIt=false\n                    if (force[3]>maxPullForce) then breakIt=true end\n                    sf=math.sqrt(force[1]*force[1]+force[2]*force[2])\n                    if (sf>maxShearForce) then breakIt=true end\n                    if (torque[1]>maxPeelTorque) then breakIt=true end\n                    if (torque[2]>maxPeelTorque) then breakIt=true end\n                    if (breakIt) then\n                        -- We break the link:\n                        sim.setLinkDummy(l,-1)\n                        sim.setObjectParent(l,b,true)\n                        m=sim.getObjectMatrix(l2,-1)\n                        sim.setObjectMatrix(l,-1,m)\n                    end\n                end\n            end\n        end\n    end\nend \n--by 40823214 \n', 'tags': '', 'url': 'w16.html'}]};